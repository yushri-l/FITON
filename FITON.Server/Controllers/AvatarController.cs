using Microsoft.AspNetCore.Mvc;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using System.Text;
using System.Text.Json;
using Microsoft.AspNetCore.Authorization;

[ApiController]
[Authorize]
[Route("api/[controller]")]
public class AvatarController : ControllerBase
{
    private readonly IConfiguration _configuration;
    private readonly BlobServiceClient _blobServiceClient;
    private readonly ILogger<AvatarController> _logger;
    private readonly HttpClient _httpClient;

    public AvatarController(IConfiguration configuration, ILogger<AvatarController> logger, IHttpClientFactory httpClientFactory)
    {
        _configuration = configuration;
        _logger = logger;
        _httpClient = httpClientFactory.CreateClient();

        // Initialize Azure Blob Storage client
        var storageConnectionString = _configuration["AzureStorage:ConnectionString"];
        _blobServiceClient = new BlobServiceClient(storageConnectionString);
    }

    [HttpPost("generate")]
    public async Task<IActionResult> GenerateAvatar([FromBody] AvatarRequest request)
    {
        try
        {
            _logger.LogInformation("Starting avatar generation using Gemini Free API");

            // Generate image using Gemini Free API
            var imageUrl = await GenerateImageWithGeminiFree(request);

            if (string.IsNullOrEmpty(imageUrl))
            {
                throw new Exception("Gemini API did not return an image URL");
            }

            // Download the image and upload to Azure Storage
            var finalImageUrl = await DownloadAndStoreImage(imageUrl);

            _logger.LogInformation("Avatar generated and stored successfully");

            return Ok(new AvatarResponse { ImageUrl = finalImageUrl });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating avatar");
            return StatusCode(500, new { error = ex.Message });
        }
    }

    private async Task<string> GenerateImageWithGeminiFree(AvatarRequest request)
    {
        var apiKey = _configuration["Gemini:ApiKey"];
        var prompt = CreatePrompt(request);

        // Using Gemini Pro model for text generation (free tier)
        var requestBody = new
        {
            contents = new[]
            {
                new
                {
                    parts = new[]
                    {
                        new
                        {
                            text = prompt
                        }
                    }
                }
            },
            generationConfig = new
            {
                temperature = 0.7,
                topK = 40,
                topP = 0.95,
                maxOutputTokens = 2048,
            }
        };

        var url = $"https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent?key={apiKey}";

        var json = JsonSerializer.Serialize(requestBody);
        var content = new StringContent(json, Encoding.UTF8, "application/json");

        var response = await _httpClient.PostAsync(url, content);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            throw new Exception($"Gemini API call failed: {response.StatusCode} - {errorContent}");
        }

        var responseContent = await response.Content.ReadAsStringAsync();
        var geminiResponse = JsonSerializer.Deserialize<GeminiResponse>(responseContent);

        // For free tier, we get text description. We'll use this to generate an image via a free image API
        var imageDescription = geminiResponse?.candidates?[0].content.parts[0].text;

        if (string.IsNullOrEmpty(imageDescription))
        {
            throw new Exception("No content generated by Gemini");
        }

        // Use a free image generation service (like Unsplash, Picsum, or DALL-E free alternatives)
        return await GenerateImageFromDescription(imageDescription);
    }

    private async Task<string> GenerateImageFromDescription(string description)
    {
        // Method 1: Use Unsplash API (free tier) - requires registration
        // return await GenerateUnsplashImage(description);

        // Method 2: Use Picsum for placeholder (limited but free)
        // return "https://picsum.photos/512/512";

        // Method 3: Use a free DALL-E alternative or stable diffusion API
        // For now, we'll use a placeholder service
        return await GeneratePlaceholderImage(description);
    }

    private async Task<string> GeneratePlaceholderImage(string description)
    {
        // Using a placeholder service that generates images based on text
        // Note: This is a simplified example. You might want to use a proper free image generation API
        try
        {
            // Placeholder.com with text (free)
            var encodedDescription = Uri.EscapeDataString(description.Length > 50 ? description.Substring(0, 50) + "..." : description);
            return $"https://placehold.co/600x400/667eea/ffffff?text={encodedDescription}";
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to generate placeholder image, using fallback");
            return "https://picsum.photos/512/512";
        }
    }

    private string CreatePrompt(AvatarRequest request)
    {
        return $@"
        Create a detailed description of a photorealistic avatar portrait for image generation:

        PHYSICAL CHARACTERISTICS:
        - Height: {request.Height}
        - Weight: {request.Weight}
        - Body type: {request.BodyType}
        - Skin tone: {request.SkinTone}
        - Hair color: {request.HairColor}
        - Hair style: {request.HairStyle}
        - Eye color: {request.EyeColor}

        ADDITIONAL SPECIFICATIONS:
        {request.AdditionalSpecifications}

        Please provide a concise, detailed description suitable for AI image generation that includes:
        - Physical appearance details
        - Facial features
        - Clothing style (professional/business casual)
        - Background (neutral, professional)
        - Lighting (natural, studio quality)
        - Expression (friendly, professional)

        Keep the description under 200 characters for image generation compatibility.
        ";
    }

    private async Task<string> DownloadAndStoreImage(string imageUrl)
    {
        try
        {
            // Download the image
            var imageResponse = await _httpClient.GetAsync(imageUrl);
            if (!imageResponse.IsSuccessStatusCode)
            {
                throw new Exception($"Failed to download image from {imageUrl}");
            }

            var imageBytes = await imageResponse.Content.ReadAsByteArrayAsync();

            // Upload to Azure Blob Storage
            return await UploadToAzureBlobStorage(imageBytes, $"{Guid.NewGuid()}.png");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to download and store image");
            throw;
        }
    }

    private async Task<string> UploadToAzureBlobStorage(byte[] imageBytes, string fileName)
    {
        var containerName = _configuration["AzureStorage:ContainerName"] ?? "avatars";
        var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);

        // Create container if it doesn't exist
        await containerClient.CreateIfNotExistsAsync(PublicAccessType.Blob);

        var blobClient = containerClient.GetBlobClient(fileName);

        using var stream = new MemoryStream(imageBytes);
        await blobClient.UploadAsync(stream, new BlobUploadOptions
        {
            HttpHeaders = new BlobHttpHeaders
            {
                ContentType = "image/png"
            }
        });

        _logger.LogInformation($"Image uploaded to Azure Blob Storage: {blobClient.Uri}");
        return blobClient.Uri.ToString();
    }

    [HttpGet("test")]
    public async Task<IActionResult> Test()
    {
        try
        {
            // Test Azure Storage
            var containerName = _configuration["AzureStorage:ContainerName"] ?? "avatars";
            var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);
            await containerClient.CreateIfNotExistsAsync(PublicAccessType.None);

            // Test Gemini API with a simple call
            var apiKey = _configuration["Gemini:ApiKey"];
            if (string.IsNullOrEmpty(apiKey))
            {
                return BadRequest("Gemini API key not configured");
            }

            return Ok(new
            {
                status = "All services configured",
                gemini = "API key present",
                azureStorage = "Connected"
            });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = ex.Message });
        }
    }
}

// Request and Response models
public class AvatarRequest
{
    public string Height { get; set; } = string.Empty;
    public string Weight { get; set; } = string.Empty;
    public string BodyType { get; set; } = string.Empty;
    public string SkinTone { get; set; } = string.Empty;
    public string HairColor { get; set; } = string.Empty;
    public string HairStyle { get; set; } = string.Empty;
    public string EyeColor { get; set; } = string.Empty;
    public string AdditionalSpecifications { get; set; } = string.Empty;
}

public class AvatarResponse
{
    public string ImageUrl { get; set; } = string.Empty;
}

// Gemini API Response models
public class GeminiResponse
{
    public List<Candidate> candidates { get; set; } = new();
}

public class Candidate
{
    public Content content { get; set; } = new();
}

public class Content
{
    public List<Part> parts { get; set; } = new();
}

public class Part
{
    public string text { get; set; } = string.Empty;
}